### Принципы программирования: KISS, DRY, YAGNI и "Антипаттерны" Чистого кода

**KISS** (Keep it simple, stupid или Keep it short and simple) - принцип проектирования, принятый в ВМС США в 1960.
Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются.
Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.

**DRY** (Don't Repeat Yourself) - это принцип программирования, который подразумевает избегание повторения одного и того
же кода или логики в разных частях программы. Вместо этого, код следует выносить в отдельные функции, классы или модули
и использовать их повторно. Это позволяет улучшить поддерживаемость кода, уменьшить количество ошибок и сделать
программу более эффективной.

**YAGNI** (You Aren't Gonna Need It) - это принцип программирования, который гласит, что не следует добавлять в код
ненужные функции или возможности, которые могут быть полезны в будущем, но на текущий момент не требуются. Вместо этого,
следует разрабатывать только необходимый функционал, чтобы избежать излишней сложности и возможных проблем в будущем.

**"Антипаттерны"** Чистого кода - это практики и принципы, которые следует избегать при написании кода, так как они
приводят к плохому качеству и сложностям в сопровождении программного обеспечения. Эти антипаттерны включают в себя
такие проблемы, как дублирование кода, длинные и запутанные методы, непонятные имена переменных и функций, ненужные
комментарии, неправильное использование исключений и многое другое. Когда разработчик следует Чистому коду, он стремится
к простоте, ясности и понятности своего кода. Это помогает улучшить читаемость, поддерживаемость и расширяемость
программы. Чистый код также способствует повышению производительности и уменьшению возможности ошибок. Использование
набора антипаттернов Чистого кода позволяет разработчикам избегать распространенных ошибок и создавать более
качественное программное обеспечение.

### Способы хранения: LocalStorage, SessionStorage и Cookie

**LocalStorage** - это механизм хранения данных веб-браузера, который позволяет веб-приложениям сохранять данные на
стороне клиента. Вот несколько способов использования LocalStorage:

1. **Установка и получение данных**: Чтобы сохранить данные в LocalStorage, можно использовать
   метод `setItem(key, value)`. Например, `localStorage.setItem('username', 'John')` сохранит значение "John" под
   ключом "username". Чтобы получить сохраненное значение, можно использовать метод `getItem(key)`.
   Например, `localStorage.getItem('username')` вернет "John".
2. **Обновление и удаление данных**: Для обновления сохраненного значения можно использовать тот же
   метод `setItem(key, value)`, указав существующий ключ. Например, `localStorage.setItem('username', 'Jane')` обновит
   значение "John" на "Jane". Чтобы удалить сохраненное значение, можно использовать метод `removeItem(key)`.
   Например, `localStorage.removeItem('username')` удалит значение, сохраненное под ключом "username".
3. **Очистка данных**: Если необходимо удалить все сохраненные значения из LocalStorage, можно использовать
   метод `clear()`. Например, `localStorage.clear()` удалит все данные, сохраненные в LocalStorage.

Важно отметить, что LocalStorage работает на уровне домена, поэтому данные будут доступны только в пределах того же
домена, где они были сохранены. Кроме того, LocalStorage имеет ограничение на объем хранимых данных (обычно около 5 МБ)
и не поддерживает сложные типы данных, такие как объекты или функции.

**SessionStorage** - это механизм хранения данных на стороне клиента веб-браузера. Он предоставляет возможность временно
сохранять данные, которые будут доступны только в пределах текущей сессии пользователя. Данные, сохраненные в
SessionStorage, не сохраняются между перезагрузками страницы или закрытиями браузера. Они остаются доступными только в
течение текущей сессии, пока вкладка или окно браузера открыты. SessionStorage предоставляет простой интерфейс для
добавления, получения и удаления данных. Он хранит данные в виде пар ключ-значение и может хранить только строки. Когда
данные сохраняются в SessionStorage, они автоматически приводятся к строковому типу данных. Важно отметить, что данные,
хранящиеся в SessionStorage, доступны только для текущего источника (домена), на котором были сохранены. Другие страницы
или фреймы, загружаемые с другого домена, не имеют доступа к данным SessionStorage. SessionStorage полезен для
временного хранения данных, таких как состояние пользовательской сессии, временные настройки или промежуточные
результаты операций. Он часто используется в веб-приложениях для сохранения данных, которые должны быть доступны только
в течение текущей сессии пользователя.

**Cookie** - это небольшие текстовые файлы, которые веб-сайты сохраняют на компьютере пользователя. Они содержат
информацию о посещенных страницах, настройках сайта и других данных, которые могут быть полезны для улучшения
пользовательского опыта. Cookie используются для различных целей, включая аутентификацию пользователя, сохранение
настроек, отслеживание активности пользователя и предоставления персонализированного контента. Они могут быть
установлены веб-сайтом самостоятельно или с помощью сторонних сервисов, таких как рекламные сети или аналитические
инструменты. Важно отметить, что некоторые пользователи могут быть озабочены приватностью и безопасностью своих данных,
связанных с использованием cookie. Поэтому веб-сайты обычно предоставляют пользователю возможность управлять настройками
cookie и выбирать, какие данные могут быть собраны.

### HTML / CSS и Базовая структура HTML документа

**HTML (HyperText Markup Language)** и **CSS (Cascading Style Sheets)** являются основными технологиями для создания и
стилизации веб-страниц. HTML отвечает за структуру и содержимое страницы, а CSS отвечает за ее внешний вид и оформление.

Базовая структура HTML документа состоит из следующих элементов:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Заголовок страницы</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
<header>
  <!-- Заголовок или логотип страницы -->
</header>

<nav>
  <!-- Навигационное меню -->
</nav>

<main>
  <!-- Основное содержимое страницы -->
</main>

<footer>
  <!-- Подвал страницы -->
</footer>
</body>
</html>

```

- `<!DOCTYPE html>` задает тип документа как HTML.
- `<html>` является корневым элементом документа.
- `<head>` содержит метаданные и связанные стили и скрипты.
- `<title>` определяет заголовок страницы, который отображается в заголовке окна браузера или на вкладке.
- `<link>` используется для подключения внешнего CSS файла.
- `<body>` содержит все видимое содержимое страницы.
- `<header>` содержит заголовок или логотип страницы.
- `<nav>` содержит навигационное меню.
- `<main>` содержит основное содержимое страницы.
- `<footer>` содержит подвал страницы.

Это лишь базовая структура HTML документа, ее можно добавлять и изменять элементы в зависимости от нужд вашей страницы.

### БЭМ методология

**БЭМ (Блок-Элемент-Модификатор)** - это методология разработки веб-интерфейсов, которая помогает создавать
масштабируемые и удобно поддерживаемые проекты. Она основана на принципе разделения интерфейса на независимые блоки,
элементы и модификаторы.

Основные концепции БЭМ

- **Блоки (Block)**: Отдельные компоненты интерфейса, которые являются независимыми и могут быть использованы в разных
  контекстах.
- **Элементы (Element)**: Части блока, которые не могут существовать отдельно от него. Они являются составной частью
  блока и имеют связь только с ним.
- **Модификаторы (Modifier)**: Модификации блока или элемента, которые изменяют их визуальное представление, состояние
  или поведение.

Преимущества БЭМ

- Улучшенная читаемость и поддерживаемость кода благодаря ясной структуре и набору соглашений.
- Масштабируемость проекта, позволяющая легко добавлять, изменять и переиспользовать блоки.
- Улучшенная возможность работы в команде благодаря стандартизированному подходу.
- Улучшенная производительность и оптимизация кода.

БЭМ методология является популярной и широко используется в веб-разработке, особенно при создании сложных и
масштабируемых проектов.

### Паттерны функционального программирования

**Паттерны функционального программирования** - это способы организации кода, которые позволяют разрабатывать
функциональные программы с использованием функций высшего порядка, неизменяемых данных и других принципов
функционального программирования. Эти паттерны помогают создавать модульный, чистый и легко поддерживаемый код.

Ниже приведены некоторые популярные паттерны функционального программирования с примерами использования на JavaScript:

**1. Композиция функций**

Композиция функций - это процесс объединения нескольких функций в одну функцию, где результат одной функции передается в
качестве аргумента следующей функции. Это позволяет создавать цепочки функций для выполнения сложных операций.

```jsx
const add = (a, b) => a + b;
const multiplyByTwo = (num) => num * 2;
const square = (num) => num * num;

const composedFunction = (num) => square(multiplyByTwo(add(num, 1)));

console.log(composedFunction(5)); // Output: 72

```

**2. Каррирование**

Каррирование - это процесс преобразования функции с несколькими аргументами в последовательность функций с одним
аргументом. Это позволяет частичное применение аргументов и создание новых функций.

```jsx
const multiply = (a, b) => a * b;
const curriedMultiply = (a) => (b) => multiply(a, b);

const multiplyByTwo = curriedMultiply(2);
console.log(multiplyByTwo(5)); // Output: 10

```

**3. Неизменяемость данных**

Неизменяемость данных - это принцип, согласно которому данные не могут быть изменены после их создания. Вместо этого
создаются новые данные при необходимости.

```jsx
const numbers = [1, 2, 3, 4, 5];

// Добавление нового элемента в массив без изменения исходного массива
const newNumbers = [...numbers, 6];

console.log(newNumbers); // Output: [1, 2, 3, 4, 5, 6]
console.log(numbers); // Output: [1, 2, 3, 4, 5]

```

**4. Рекурсия**

Рекурсия - это процесс, при котором функция вызывает саму себя. Это позволяет решать задачи, которые могут быть разбиты
на более мелкие подзадачи.

```jsx
const factorial = (n) => {
  if (n === 0) {
    return 1;
  }
  return n * factorial(n - 1);
};

console.log(factorial(5)); // Output: 120

```

**5. Функции высшего порядка**

Функции высшего порядка - это функции, которые могут принимать другие функции в качестве аргументов или возвращать
функции в качестве результата. Это позволяет абстрагировать операции и создавать более гибкий и переиспользуемый код.

```jsx
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;

const calculate = (operation) => (a, b) => operation(a, b);

const addResult = calculate(add);
console.log(addResult(5, 3)); // Output: 8

const subtractResult = calculate(subtract);
console.log(subtractResult(10, 7)); // Output: 3

```

**6. Преобразование данных**

Преобразование данных - это паттерн, который позволяет преобразовывать и обрабатывать данные с помощью функций высшего
порядка, таких как `map`, `filter` и `reduce`. Это позволяет упростить и улучшить обработку коллекций данных.

```jsx
const numbers = [1, 2, 3, 4, 5];

// Применение функции к каждому элементу массива
const doubledNumbers = numbers.map((num) => num * 2);
console.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]

// Фильтрация элементов массива по условию
const filteredNumbers = numbers.filter((num) => num % 2 === 0);
console.log(filteredNumbers); // Output: [2, 4]

// Суммирование всех элементов массива
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // Output: 15

```

**7. Мемоизация**

Мемоизация - это паттерн, который позволяет кэшировать результаты вызовов функций для улучшения производительности. При
повторных вызовах с теми же аргументами, функция использует кэшированный результат вместо выполнения вычислений снова.

```jsx
const memoize = (fn) => {
  const cache = {};
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache[key]) {
      return cache[key];
    }
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
};

const fibonacci = memoize((n) => {
  if (n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(5)); // Output: 5 (cached)
console.log(fibonacci(10)); // Output: 55 (cached)

```

Это лишь некоторые паттерны функционального программирования, которые могут быть использованы для разработки
функциональных программ.

### Способы позиционирования контента на странице

Существуют различные способы позиционирования контента на веб-странице:

1. **Потоковый** (Flow): Контент отображается в порядке, в котором он находится в HTML-разметке. По умолчанию элементы
   располагаются друг за другом, начиная сверху и продолжая до низа страницы.
2. **Относительное позиционирование** (Relative): Это позволяет контролировать позицию элемента относительно его
   исходного положения. Можно использовать свойства `top`, `bottom`, `left` и `right`, чтобы сдвинуть элемент вверх,
   вниз, влево или вправо относительно его исходного местоположения.
3. **Абсолютное позиционирование** (Absolute): Позволяет точно задать позицию элемента относительно его ближайшего
   позиционированного родителя. Можно использовать свойства `top`, `bottom`, `left` и `right`, чтобы указать, где должен
   находиться элемент.
4. **Фиксированное позиционирование** (Fixed): Это позволяет элементу оставаться на фиксированной позиции относительно
   видимой области окна браузера, даже при прокрутке страницы. Можно использовать свойства `top`, `bottom`, `left`
   и `right`, чтобы точно задать позицию элемента.
5. **Статическое позиционирование** (Static): Это значение по умолчанию для всех элементов. Элементы с
   позиционированием "static" не задаются никакими свойствами позиционирования и отображаются в потоке документа.

Выбор способа позиционирования контента зависит от требований дизайна и взаимодействия на веб-странице.

### Вес селекторов

Селекторы в CSS используются для выбора элементов на веб-странице и применения к ним стилей. Каждый селектор имеет свой
вес, который определяет приоритет применения стилей. В случае конфликта между стилями, селектор с более высоким весом
будет иметь больший приоритет.

Общие селекторы и их вес:

- Теговый селектор (например, `div`, `p`): Вес - 1
- Классовый селектор (например, `.my-class`): Вес - 10
- Идентификаторный селектор (например, `#my-id`): Вес - 100
- Вложенный селектор (например, `div p`): Вес - сумма весов каждого селектора
- Вес селектора можно увеличить с помощью комбинаторов (например, `div > p`, `div + p`)

**Примеры кода:**

Пример 1: Использование тегового селектора

```css
div {
  color: blue;
}

```

Пример 2: Использование классового селектора

```css
.my-class {
  font-size: 16px;
}

```

Пример 3: Использование идентификаторного селектора

```css
#my-id {
  background-color: yellow;
}

```

Пример 4: Использование вложенного селектора

```css
div p {
  font-weight: bold;
}

```

Пример 5: Использование комбинатора

```css
div > p {
  text-decoration: underline;
}

```

Важно помнить, что при использовании селекторов с разными весами, браузер будет применять стили с наивысшим приоритетом.
